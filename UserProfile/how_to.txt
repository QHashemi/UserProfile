Setup database using Entity Framework Core:
1. Create folder name Entities and add User.cs entity
2. Create folder name Data and add DbContext.cs
3. Create Db in sql server management studio
4. Connect db with visual studio and copy the connection string
5. Add connection string in appsettings.json
6. Add DbContext in Program.cs
7. Run the migration commands in Package Manager Console
   - Add-Migration InitialCreate
   - Update-Database


Create AuthController:
1. Create folder name Controllers and add AuthController.cs
2. Add Register and Login methods in AuthController.cs
3. Create folder name DTOs and add UserRegisterDto.cs and UserLoginDto.cs
4. Create folder name Services and add AuthService.cs
5. Create folder name Interfaces and add IAuthService.cs
6. User AuthServices in AuthController.cs


Setup Helth Checks:
1. Create new Controller name HealthController.cs
2. Add /health
3. add /api
4. add /db
6. add /
7. add /ready
8. add /live


Setup Scalar:
1. Install package name scalar.AspNetCore
2. Add Scalar in Program.cs
if (app.Environment.IsDevelopment())
	{
		app.MapScalarApiReference();
	}


Implement JWT to secure Enpoint:
1. Install package name System.IdentityModel.Tokens.Jwt
2. Add JWT settings in appsettings.json
3. Create GenerateTokenFunction in AuthService.cs
4. Add AccessToken propertie inside LoginResponseDto
   public string AccessToken { get; set; }
5. Send Response with user information and token.


Secure Endpoint with JWT Middleware
1. Install package name Microsoft.AspNetCore.Authentication.JwtBearer
2. Add builder.Services.AddAuthentication configuration in Program.cs
3. Set [Authrize] options for every end point you wanna secure


Secure Endpoint with JWT and Role
1. Update User Entity to include Role property
   public string Role { get; set; }
2. Run Follwing command to update Database Table
    add-migration AddUserRole
	update-database
3. Create new endpoint inside UserController for assigning roles
4. Update Claims in GenerateAccessToken method to include Role claim
    claims.Add(new Claim(ClaimTypes.Role, user.Role));
5. Update the controller methods to use role-based authorization
6. Update Response and Request Dto
7. The Role in [Authorize(roles="admin")] must match the Role assigned to the user during registration or through role assignment.


Implement Refresh Token
1. Update Entitiy with Refresh Token and Refresh Token Expire Time, so that we can save the refresh token inside database
2. Run following command to update entity: 
	Add-Migration AddRefreshToken
	Update-Database
3. Create three function to process refresh token as following:
	GenerateRefreshToken => Generate 64Bit Refresh Token
	GenerateAndSaveRefreshTokenAsync => Generate 64Bit and Save the refresh token in DB
	ValidateRefreshTokenAsync => Validate Refresh Token with UserId and return new AcceseToken and RefreshToken
4. Create Service Name RefreshTokenAsync to combine all the function and Return as service to RefreshToken Controller
5. Create EndPoint inside controller name RefreshToken  and Send back the new AccessToken and RefreshToken to the Client.


Handling Errors Middlewares: (IT WILL HANLDE REQUEST AND RESPONSE ERROR)
1. Create error handling middleware like ExceptionHandlingMiddleware.cs
2. Add Middleware inside Program.cs and it should be before UseAuthorization and MapControllers
3. Add Middleware as following: app.UseMiddleware<ExceptionHandlingMiddleware>();
4. Remove every try and catch block because the middlware handle everything by it self.
	try { ... } catch { ... }
5. Use Middleware as following:
	throw new InvalidOperationException("Boom");
	throw new Exception("Something went wrong");
	...



Add Logger middleware to log messages via packages:
1. Install package name Serilog as following:

	dotnet add package Serilog.AspNetCore
	dotnet add package Serilog.Sinks.File
	dotnet add package Serilog.Sinks.Console

2. Add Logger configuration in Program.cs
	Log.Logger = new LoggerConfiguration()
		.MinimumLevel.Debug()
		.WriteTo.Console()
		.WriteTo.File("Logs/log.txt", rollingInterval: RollingInterval.Day)
		.CreateLogger();



Add CustomLogger:
1. Create CustomLogger class
2. Create Interface CustomLogger
3. Register CustomLogger inside program.cs

Add LoggerMiddleware:
1. Create RequestLoggingMiddleware.cs file inside Middleware folder
2. Add Logic 
3. Use CustomLogger to log information into a files


Middleware for Secure your web application by automatically setting HTTP security headers (It will god for securing app against SQL Injection or any other stoff)
1. Use Built in Middleware to secure app.
2. Create Middleware name SecureHeaderMiddleware.cs
3. add Login of middleware
4. Inject the middlware in program.cs like following:
	app.UseMiddleware<SecureHeaderMiddleware>();

	

Add Rate-Limiting, so that the user not send multiple request:
1. Install package name AspNetCoreRateLimit
2. Add configuation inside the program.cs
	builder.Services.AddMemoryCache();
	builder.Services.Configure<IpRateLimitOptions>(options =>
	{
		options.GeneralRules = new List<RateLimitRule>
		{
			new RateLimitRule
			{
				Endpoint = "*", // all endpoints
				Limit = 10,    // 10 requests
				Period = "1m"   // per 1 minute
			}
		};
	});
	builder.Services.AddInMemoryRateLimiting();
	builder.Services.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();
3. Add the middleware:
	app.UseIpRateLimiting();


Implement Credential Stuffing Protection to prevent attackers from repeatedly trying passwords.

1. Create LoginAttemptTracker.cs
	Use a ConcurrentDictionary to track failed login attempts per user/IP.
	Store both the count of failures and timestamp of last attempt.

2. Integrate LoginAttemptTracker in the login flow
	Before login, check if the user/IP is temporarily blocked (IsBlocked).
	After failed login, record the attempt (RecordFailure).
	After successful login, reset the counter (Reset).

3. Optional: Use a sliding time window (e.g., block after 5 failures within 10 minutes).
4. Result: Protects against brute-force and credential-stuffing attacks while still allowing normal users to log in.



Implement Middleware to block ips that you dont want to access your backend:
1. Create Middleware name BlockSuspiciousIpsMiddleware.cs.
2. Register Middleware inside the program.cs



Api Testing ⇒ Unit Testing

1. Create a new xUnit Test Project (Name it after the project you are testing).
	Example: UserProfile => UserProfile.Tests

2. The new Method will be create it automaticly inside the test project tree
3. Rename the TestProject to you aktuall controller, Service, Helper etc, that you wanna test.
4. Create Fake Database connection like below:
	private readonly DbContextOptionsBuilder<AppDbContext> dbContext= new();
	private AppDbContext ReturnContext() 
    {
        var options = dbContext.UseInMemoryDatabase(databaseName: "TestDb").Options;
        using var context = new AppDbContext(options);
        return context;
    }
5. Create Method with name of you EndPoint you wanna test:
	Example: In this example i wanna test Health of the api
	[Fact]
        public void HealthTest()
        {
            // Arrange ================>
            var healthController = new ApiHealthController(ReturnContext(), CreateFakeLogger());

            // Act ==================>
            var actionResult = healthController.GetHealth();

            // Assert ==================>
            var okResult = actionResult.Result as ObjectResult; // unwrap safely
            var healtResult = okResult?.Value as TestControllersResponseDto;
            Assert.NotNull(healtResult);
            Assert.Equal("Healthy", healtResult.Status); 
        }
6. After creation run test Project to test api

6. To Create Fake instance of ICustomLogger need to install moq package.
7. Use the package as following.
	private static ICustomLogger CreateFakeLogger()
        {
            return Mock.Of<ICustomLogger>();
        }


Configure Config folder
1. Create Different configuration file inside the Config folder.
2. after that we can inject the configuration file into Program.cs

Create folder name Startup
1. We can move every builder Dependiencies in Seprate file.
2. Then we can Bind the dependencie inside Program.cs



Add Cors Configuration.
1. Creat file name CorsConfiguration.cs
2. Add Logic of Cors
3. Inject the Configuration inside the Program.cs as following:
Example: app.ApplyCorsConfig();
4. Inject the Cors also inside the Dependencies config as well.
Example: builder.Services.AddCorsServices();


Create HealthCheck with packages.
1. Install following Package AspNetCore.HealthChecks.UI.Client
2. Create folder name HealthCheck 
3. Inside HealthCheck folder Create follwoing files:
	HealthyHealthCheck.cs
	DegradedHealthCheck.cs
	RandomHealthCheck.cs
	UnhealtyHealthCheck.cs

4. Create file name HealthCheckConfiguration.cs and Logic of the configuration
5. Inject HealthCheckService in DependenciesConfig.cs
   Example:  builder.Services.AddAllHealthChecks();
6. Inject HealthCheckService inside the program.cs
   Example: app.MapAllHealthChecks();

